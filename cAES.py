#!/usr/bin/env python
import sys

sBox = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 ]
invSBox =[ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d ]
nRounds = {128: 10, 192: 12, 256: 14}

#Examples extracted from NIST Standard (https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf)

plainText = [0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff]

keyAes128 = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f]
keyAes192 = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17]
keyAes256 = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f]

expectedOutputAes128 = [0x69,0xc4,0xe0,0xd8,0x6a,0x7b,0x04,0x30,0xd8,0xcd,0xb7,0x80,0x70,0xb4,0xc5,0x5a]
expectedOutputAes192 = [0xdd,0xa9,0x7c,0xa4,0x86,0x4c,0xdf,0xe0,0x6e,0xaf,0x70,0xa0,0xec,0x0d,0x71,0x91]
expectedOutputAes256 = [0x8e,0xa2,0xb7,0xca,0x51,0x67,0x45,0xbf,0xea,0xfc,0x49,0x90,0x4b,0x49,0x60,0x89]

def printUsage():
	print "Usage: pythong cAES.py [128/192/256] [plaintext]"
	exit()

def addRoundKey(blockPT, blockKey):
#Bitwise XOR between the state matrix (key) and the round subkey
	print "Add Round Key\n========="
	return blockPT^blockKey

def gfDegree(a) :
  res = 0
  a >>= 1
  while (a != 0) :
    a >>= 1;
    res += 1;
  return res

def multiply(v, G):
    result = []
    for i in range(len(G[0])): #this loops through columns of the matrix
        total = 0
        for j in range(len(v)): #this loops through vector coordinates & rows of matrix
            total += v[j] * G[j][i]
        result.append(total)
    return result

def subBytes(byte):
	#Treure V(x) del byte, y multiplicaro per la matriu i sumarli el vector de la pag 16
	print "Sub Bytes\n========="
	v = 0x1B
  	g1 = 1
  	g2 = 0
  	j = gfDegree(byte) - 8

	while (byte != 1):
		if (j < 0):
			byte, v = v, byte
      		g1, g2 = g2, g1
			j = -j

			byte ^= v << j
			g1 ^= g2 << j

		byte %= 256  # Emulating 8-bit overflow
		g1 %= 256 # Emulating 8-bit overflow

		j = gfDegree(byte) - gfDegree(v)

	# Ara a g1 tenim la inversa multiplicativa V(x)
	m = [[1,0,0,0,1,1,1,1],
		 [1,1,0,0,0,1,1,1],
		 [1,1,1,0,0,0,1,1],
		 [1,1,1,1,0,0,0,1],
		 [1,1,1,1,1,0,0,0],
		 [0,1,1,1,1,1,0,0],
		 [0,0,1,1,1,1,1,0],
		 [0,0,0,1,1,1,1,1]]

	y = [1,1,0,0,0,1,1,0]

	aux = multiply(g1, m)
	res = aux + y
  	return res

def shiftRows(block):
	print "Shift Rows\n========="
	return [block[0],
			[block[1][1],block[1][2],block[1][3],block[1][0]],
			[block[2][2],block[2][3],block[2][0],block[2][1]],
			[block[3][3],block[3][0],block[3][1],block[3][2]]]

def mixColumns(block):
	print "Mix Columns\n========="
	mixedBlock = {4}
	#TODO: Pillar cada columna del block be
	for column in block
		a = {4}
		b = {4}
		mixedColumn = {4}
		# Omplir les matrius a i b amb els bytes originals y tractats respectivament
		for i in range(0,3)
			a[i] = column[i]
			b[i] = ((column[i]<<1) & 0xFF) ^ ((column[i]>>7) * 0x1B)
		
		#Omplir la columna amb els bytes que toca per cada posici√≥ (A, 2A o 3A)
		mixedColumn.append(b[0] ^ (b[1] ^ a[1]) ^ a[2] ^ a[3])
		mixedColumn.append(a[0] ^ b[1] ^ (b[2] ^ a[2]) ^ a[3])
		mixedColumn.append(a[0] ^ a[1] ^ b[2] ^ (b[3] ^ a[3]))
		mixedColumn.append((b[0] ^ a[0]) ^ a[1] ^ a[2] ^ b[3])

		mixedBlock.append(mixedColumn)

def rotate(byte):
	a = byte[0]
	for i in range(3)
		byte[i] = byte[i+1]
	byte[3] = a
	return byte

def rcon(byte):	
	c = 1
	if byte == 0:
		return 0
	while byte != 1:
		c = (c * 2) & 0xFF
		byte--
	return c


def keyExpansion(keylength):
	resultKey = []
	if keyLength = 128:
		# White
		resultKey += keyAes128
		for i in range(1,10):
			# Green
			t =  resultKey[i*16-4]+resultKey[i*16-3]+resultKey[i*16-2]+resultKey[i*16-1]
			rotate(t)
			for a in range(0,3):
				t[a] = subBytes(t[a])
			t[0] ^= rcon(i)
			# Red
			resultKey ^= resultKey[((i+1)*16)-16]
	if keyLength == 192:

	if keyLength == 256:

def invSubBytes(byte):
	print "Inv Sub Bytes\n========="

def invShiftRows(block):
	print "Inv Shift Rows\n========="

def invMixColumns(block):
	print "Inv Mix Columns\n========="

def cipher():
	"Initial AddRoundKey"
	addRoundKey()
	for i in range(0,nRounds.get(keyLenght)):
		print "Loop N"
		subBytes()
		shiftRows()
		mixColumns()
		addRoundKey()
	print "Last Round"
	subBytes()
	shiftRows()
	addRoundKey()

def decipher():
	addRoundKey()
	invShiftRows()
	invSubBytes()
	for i in range(0,nRounds.get(keyLenght)):
		addRoundKey()
		invMixColumns()
		invShiftRows()
		invSubBytes()

def checkSBOX():
	pos = 0
	for posByte in range(0x00, 0xFF):
		if SBox[pos] != subBytes(posByte):
			print "Esperat: " + str(SBox[pos]) +  "\n Calculat: " + str(subBytes(posByte)) + "\n"
			return FALSE
		pos+=1
	return TRUE

### MAIN ###
args = sys.argv[1:]

if str(args[0]) == "-h" or str(args[0]) == "--help":
	printUsage()
else:
	keyLenght = int(args[0])

	if len(args) != 2:
		print "ERROR: 2 arguments required"
		printUsage()
	elif 128 != keyLenght and 192 != keyLenght and 256 != keyLenght:
		print "ERROR: First argument must be a valid keyLenght"
		printUsage()
	)

	if (checkSBOX()) print "SBOX correcta"
	else print "SBOX incorrecta"